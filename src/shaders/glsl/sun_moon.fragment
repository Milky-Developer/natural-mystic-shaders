// __multiversion__
// This signals the loading code to prepend either #version 100 or #version 300 es as apropriate.

#include "fragmentVersionCentroid.h"

#if __VERSION__ >= 300

#if defined(TEXEL_AA) && defined(TEXEL_AA_FEATURE)
_centroid in highp vec2 uv;
#else
_centroid in vec2 uv;
#endif

#else

varying vec2 uv;

#endif

#include "uniformPerFrameConstants.h"
#include "uniformShaderConstants.h"
#include "util.h"
#include "natural-mystic-hacks.h"
#include "natural-mystic-noise.h"

LAYOUT_BINDING(0) uniform sampler2D TEXTURE_0;

varying vec2 localPos;
varying float duskOrDown;
varying float night;

vec4 renderSun(vec2 pos) {
    const float radius     = 0.08;
    const float sharpness  = 0.2;  // The smaller the sharper the edge will be.
    const float colorScale = 2.5;
    const vec3  baseColor  = vec3(1.0, 0.55, 0.15);

    /* The fog color is white during the daytime and is red at dusk
     * and dawn. We use it as the color of the sun. We also hide the
     * sun when it's raining, hence the CURRENT_COLOR.a.
     */
    vec4 sunColor = vec4(FOG_COLOR.rgb * baseColor * colorScale, CURRENT_COLOR.a);

    /* The body of the sun in a Signed Distance Field. */
    float sdf        = length(pos) - radius;
    float brightness = 1.0 - smoothstep(0.0, radius * sharpness, sdf);

    /* Render halo, or sort of. When it's daytime and is clear, quite
     * a large area around the sun should be rendered extremely
     * brightly. We do this by using the distance between the current
     * pixel and the border of the sun as the factor of the
     * brightness, i.e. the closer the brighter. */
    float halo = (1.0 - duskOrDown) * 0.7;
    brightness = max(brightness, (1.0 - sdf) * halo);

    return clamp(sunColor * brightness, 0.0, 1.0);
}

/* Based on https://www.shadertoy.com/view/XsdGzX
 * and http://learnwebgl.brown37.net/09_lights/lights_diffuse.html
 */
float diffuseSphere(vec2 pos, float radius, vec3 light) {
    float sq = radius*radius - pos.x*pos.x - pos.y*pos.y;

    if (sq < 0.0) {
        return 0.0;
    }
    else {
        float z      = sqrt(sq);
        vec3  normal = normalize(vec3(pos, z));
        return max(0.0, dot(normal, light));
    }
}

/* Translate the texture UV into the phase of moon. This function
 * returns [0, 2π) where 0 is the new moon and π is the full
 * moon. This is a hack.
 */
float moonPhase(vec2 texUV) {
    float x = floor(texUV.x * 4.0) * 0.25; // {0, 0.25, 0.5, 0.75}
    float y = step(0.5, texUV.y);          // {0, 1}
    return (x + y) * 3.14159;
}

/* Huge thanks for ESBE-2G shaders. I took its moon renderer as a
 * reference (although I didn't use it directly).
 */
vec4 renderMoon(vec2 pos, float phase) {
    const float radius    = 0.11;
    const float sharpness = 0.15; // The smaller the sharper the edge will be.
    const vec3  baseColor = vec3(1.0, 0.95, 0.81);
    const vec2  resolution = vec2(0.06);

    /* We hide the moon when it's raining, hence the
     * CURRENT_COLOR.a.
     */
    vec4 moonColor = vec4(baseColor, CURRENT_COLOR.a);

    /* The body of the moon in a Signed Distance Field. */
    float pDistance  = length(pos);
    float sdf        = pDistance - radius;

    /* Compute the light vector based on the phase of moon. */
    vec3 light = vec3(sin(phase), 0.0, -cos(phase));

    /* Perform a diffuse lighting to render the phase of moon. */
    float diffuse = diffuseSphere(pos, radius, light);
    /* Hacky adjustment of the diffuse light. */
    float brightness = smoothstep(0.2, 0.8, min(diffuse + 0.3, 1.0));

    /* Generate the texture of the moon with 2D simplex noise. */
    float tex = simplexNoise(pos / resolution);
    brightness *= 1.0 - clamp(tex, 0.0, 1.0) * 0.05;

    /* Apply the sharpness to the surface. */
    brightness *= 1.0 - smoothstep(radius - radius * sharpness, radius, pDistance);

    return clamp(moonColor * brightness, 0.0, 1.0);
}

void main() {
#if 0
#if !defined(TEXEL_AA) || !defined(TEXEL_AA_FEATURE)
	vec4 diffuse = texture2D( TEXTURE_0, uv );
#else
	vec4 diffuse = texture2D_AA(TEXTURE_0, uv );
#endif

#ifdef ALPHA_TEST
	if(diffuse.a < 0.5)
		discard;
#endif

	gl_FragColor = CURRENT_COLOR * diffuse;
#endif

#if 0
    gl_FragColor = CURRENT_COLOR;
#endif

#if 1
    if (night < 0.5) {
        gl_FragColor = renderSun(localPos);
    }
    else {
        float phase  = moonPhase(uv);
        gl_FragColor = renderMoon(localPos, phase);
    }

#endif

#if 0
    gl_FragColor = CURRENT_COLOR;
#endif

#if 0
    gl_FragColor = FOG_COLOR;
#endif

#if 0
    float l = length(localPos);
    float s = max(cos(min(l * 12., 1.58)), (.5 - l * .7));
    gl_FragColor = vec4(1., .95, .81, smoothstep(.7, 1., FOG_CONTROL.y)) * s;
#endif

#if 0
    vec4 f_color   = FOG_COLOR;
    vec4 l_f_color = max(f_color, vec4(1.0));

    float dusk_f  = pow(clamp(1.0 - f_color.b * 1.2, 0.0, 1.0), 0.5); // 1.0 when it's dusk
    float night_f = pow(clamp(1.0 - f_color.r * 1.5, 0.0, 1.0), 0.3); // 1.0 when it's night
    float rain_f  = pow(FOG_CONTROL.y, 5.0); // 1.0 when it's clear, 0.0 when it's raining

    float c0 = 1.0 - pow(length(localPos * 51.0), night_f * 9.0 + 0.6);
    float c1 = 1.0 - pow(length(localPos *  2.0),
                         0.5 * pow(f_color.g, 5.0) * (1.0 - dusk_f) + (1.0 - f_color.b) * 0.1);

    vec4 sun_color = vec4(l_f_color.r * 0.9,
                          1.65 - f_color.b,
                          1.2  - f_color.b,
                          1.0);

    vec4 sun = vec4(sun_color.rgb, clamp(c1 * rain_f, 0.0, 1.0));
    gl_FragColor = mix(sun, sun_color, clamp(c0 * rain_f, 0.0, 1.0));
#endif
}

// Local Variables:
// mode: glsl
// indent-tabs-mode: nil
// End:
