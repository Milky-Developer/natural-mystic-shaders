// __multiversion__
// This signals the loading code to prepend either #version 100 or #version 300 es as apropriate.

#include "fragmentVersionCentroid.h"

#if __VERSION__ >= 300
	#ifndef BYPASS_PIXEL_SHADER
		#if defined(TEXEL_AA) && defined(TEXEL_AA_FEATURE)
			_centroid in highp vec2 uv0;
			_centroid in highp vec2 uv1;
		#else
			_centroid in vec2 uv0;
			_centroid in vec2 uv1;
		#endif
	#endif
#else
	#ifndef BYPASS_PIXEL_SHADER
		varying vec2 uv0;
		varying vec2 uv1;
	#endif
#endif

/* Workaround for https://bugs.mojang.com/browse/MCPE-40059 */
#if defined(MCPE40059)
varying highp vec3 wPos;
varying highp vec3 relPos;
varying highp vec3 normal;
varying float flickerFactor;
varying float desatFactor;
varying float waterPlane;
#endif

varying vec4 color;

#ifdef FOG
varying vec4 fogColor;
#endif

#include "uniformShaderConstants.h"
#include "uniformPerFrameConstants.h"
#include "util.h"
#include "natural-mystic-color.h"
#include "natural-mystic-config.h"
#include "natural-mystic-light.h"
#include "natural-mystic-hacks.h"
#include "natural-mystic-water.h"

LAYOUT_BINDING(0) uniform sampler2D TEXTURE_0;
LAYOUT_BINDING(1) uniform sampler2D TEXTURE_1;
LAYOUT_BINDING(2) uniform sampler2D TEXTURE_2;

void main()
{
#ifdef BYPASS_PIXEL_SHADER
	gl_FragColor = vec4(0, 0, 0, 0);
	return;
#else 

#if USE_TEXEL_AA
	vec4 diffuse = texture2D_AA(TEXTURE_0, uv0);
#else
	vec4 diffuse = texture2D(TEXTURE_0, uv0);
#endif
	
#ifdef SEASONS_FAR
	diffuse.a = 1.0;
#endif

#if USE_ALPHA_TEST
	#ifdef ALPHA_TO_COVERAGE
	#define ALPHA_THRESHOLD 0.05
	#else
	#define ALPHA_THRESHOLD 0.5
	#endif
	if(diffuse.a < ALPHA_THRESHOLD)
		discard;
#endif
	
vec4 inColor = color;

#if defined(BLEND)
	diffuse.a *= inColor.a;
#endif

#ifndef SEASONS
	#if !USE_ALPHA_TEST && !defined(BLEND)
		diffuse.a = inColor.a;
	#endif
	
	diffuse.rgb *= inColor.rgb;
#else
	vec2 uv = inColor.xy;
	diffuse.rgb *= mix(vec3(1.0,1.0,1.0), texture2D( TEXTURE_2, uv).rgb*2.0, inColor.b);
	diffuse.rgb *= inColor.aaa;
	diffuse.a = 1.0;
#endif

	/* Fetch the level of daylight (i.e. the one which darkens at
	 * night) from the light map passed by the upstream. Note that we
	 * intentionally reduce the dynamic range because the upstream
	 * daylight level doesn't drop to zero at night. */
	float daylight = texture2D(TEXTURE_1, vec2(0.0, 1.0)).r;
	daylight = smoothstep(0.4, 1.0, daylight);

	/* Fetch the level of ambient light from the light map passed by
	 * the upstream. The constant multiplifier is determined so the
	 * intensity will be 6 on the Overworld and 26 in the
	 * Nether/End. */
	float ambientBrightness = texture2D(TEXTURE_1, vec2(0.0, 0.0)).r * 44.797;

	/* Calculate the color of the ambient light based on the fog
	 * color. We'll use it at several places. Note that the .a
	 * component denotes the intensity. */
#if defined(UNDERWATER)
	const bool isUnderwater = true;
#else
	const bool isUnderwater = false;
#endif /* defined(UNDERWATER) */

	vec3 ambientColor;
#if defined(FOG)
	if (isRenderDistanceFog(FOG_CONTROL)) {
		/* Don't use the fog color in this case, as it would be
		 * slightly different from the color of near terrain. */
		ambientColor = ambientLightColor(uv1.y, daylight);
	}
	else {
		ambientColor = ambientLightColor(fogColor);

		/* The existence of bad weather fog (and also underwater fog)
		 * should increase the intensity of ambient light (#32). But
		 * at night it should work the other way.
		 */
		ambientBrightness *= mix(0.9, 1.4, daylight);
	}
#else
	ambientColor = ambientLightColor(uv1.y, daylight);
#endif /* defined(FOG) */

	/* Save the diffused color here as the color of the material. We
	 * are going to redo all the lightings with our own HDR method. */
	vec3 pigment = diffuse.rgb;

	/* Accumulate all the light to one linear RGB vector. We are going
	 * to use it for diffuse lighting, and also specular lighting. */
	vec3 light = vec3(0);

	light += ambientLight(ambientColor, ambientBrightness);
#if defined(FOG)
	/* When it's raining the sunlight shouldn't affect the scene
	 * (#24), but this has a side effect. Shadows appear and disappear
	 * all of sudden (#33).
	 */
	if (isUnderwater || isRenderDistanceFog(FOG_CONTROL)) {
		light += sunlight(uv1.y, daylight);
		light += moonlight(uv1.y, daylight);
	}
#else
	light += sunlight(uv1.y, daylight);
	light += moonlight(uv1.y, daylight);
#endif /* FOG */
	light += skylight(uv1.y, daylight);
#if defined(MCPE40059)
	light += torchLight(uv1.x, uv1.y, daylight, flickerFactor);
#endif

	/* Light sources should be significantly brighter than normal
	 * objects. */
#if defined(ALWAYS_LIT)
	light += emissiveLight(flickerFactor);
#endif

	/* Now we finished accumulating light. Compute the diffuse light
	 * and the specular light here. We assume the color of specular
	 * light is always the same as the color of accumulated light. */
	diffuse.rgb = pigment * light;
#if defined(MCPE40059) && defined(FANCY)
	/* It is tempting to do this only when defined(BLEND), but if we
	 * do that water in far terrain will have different colors. */
	if (waterPlane > 0.0) {
		vec4 specular = waterSpecularLight(diffuse.a, light, wPos, relPos, TIME, normal);
		diffuse.rgb += specular.rgb * waterPlane;
		diffuse.a    = mix(diffuse.a, specular.a, waterPlane);
	}
#endif

	diffuse.rgb = uncharted2ToneMap(diffuse.rgb, 112.0, 1.0);
	diffuse.rgb = contrastFilter(diffuse.rgb, 1.25);

	/* Reduce the contrast of far objects (#5). The overall color
	 * should lean towards the ambient. */
#if defined(FANCY) && defined(MCPE40059)
	diffuse.rgb = mix(
		diffuse.rgb, contrastFilter(diffuse.rgb, 0.45) * ambientColor, desatFactor);
#endif

	/* We can't apply fogs before doing tone mapping, because that
	 * changes the fog color and breaks "render distance fog". */
#ifdef FOG
	if (isUnderwater || isRenderDistanceFog(FOG_CONTROL)) {
		diffuse.rgb = mix( diffuse.rgb, fogColor.rgb, fogColor.a );
	}
	else {
		/* During a bad weather everything should look dull. We do a
		 * desaturation for that (#6). The reason for the mix() is so
		 * fogs not only reduce saturation but also contrast.
		 */
		diffuse.rgb = mix(
			desaturate(diffuse.rgb, fogColor.a) * ambientColor,
			fogColor.rgb,
			fogColor.a);
	}
#endif

//#define SHOW_MATERIAL_COLOR 1
#if defined(SHOW_MATERIAL_COLOR)
	diffuse = color;
#endif

	gl_FragColor = diffuse;
	
#endif // BYPASS_PIXEL_SHADER
}

// Local Variables:
// mode: glsl
// indent-tabs-mode: t
// End:
